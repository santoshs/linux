#!/usr/bin/perl
#
# ############################################################################
# #    Copyright © Renesas Mobile Corporation 2012 . All rights reserved     #
# ############################################################################
# #                                                                          #
# # This material, including documentation and any related source code and   #
# # information, is protected by copyright controlled by Renesas. All rights #
# # are reserved. Copying, including reproducing, storing, adapting,         #
# # translating and modifying, including decompiling or reverse engineering, #
# # any or all of this material requires the prior written consent           #
# # of Renesas. This material also contains confidential information,        #
# # which may not be disclosed to others without the prior written consent   #
# # of Renesas.                                                              #
# #                                                                          #
# ############################################################################
#
# FLIC - FLash Image Creator 
#
# Usage: flic.pl [options] files
#
# Additional information:
# By default TOC names of files are generated by stripping the path. 
# It is also possible to specify both file name and TOC name on command:
# The entry full_path_name,TOCNAME (note: No whitespace around the comma) would result in
# the file full_path_name to be stored in TOC with TOC name TOCNAME.
#
use strict;
use warnings;

use Getopt::Long;

my $align;
my $minlength = 2048;
my $output;
my @offsets  = ();
my @optional = ();
my @optsubimages = ();
my $optverbose;
my @loadaddrs = ();

die "Parameter error\n" unless GetOptions("align=s"    => \$align,             # Align at 256 byte boundary: --align 256 (or --align 0x100)
                                          "output=s"   => \$output,
                                          "offset=s"   => \@offsets,           # Force offset for entries entered on command line
                                          "optional=s" => \@optional,          # Add optional files (e.g. TC) if available
                                          "load=s"     => \@loadaddrs,         # Specify load address in TOC
                                          "sub=s"      => \@optsubimages,      # Elf2flash style sub image configuration file
                                          "verbose"    => \$optverbose         # some additional debug output
                                          );

if (!defined $align) {
    $align = 4;
} else {
    $align = eval $align;
}

die "Align parameter must be a power of 2\n" unless (0 == ($align & ($align - 1)));

my $tocrange;
my @toc = ();

#
# Process sub image configuration file(s)
#
my $subimagefile;
foreach $subimagefile (@optsubimages) {
    @toc = (@toc, process_sub_image_conf_file($subimagefile, \$tocrange));
# ATV Sorting not needed for now
#    @toc = sort bystart @toc;
}

#
# Mark optional files
#
my $optional;
foreach $optional (@optional) {

    my ($optfilename, $optsize) = ($optional =~ /([0-9a-z_\.\\\/]+)(,[0-9a-fx]+)?/i);

    if (defined $optsize) {
        $optsize =~ s/^,//;
    }

    if (-e $optfilename) {

        my $content = `cat $optfilename`;

        if (defined $optverbose) {
            printf STDERR ("    NOTE:  optional $optfilename\n");
        }

        push @toc, {tocname  => strippath($optfilename),
                    filename => $optfilename,
                    content  => $content};
    } else {
        push @toc, {tocname  => strippath($optfilename),
                    optional => 1,
                    optsize  => $optsize,
                    content  => ""};
    }
}

#
# Offsets for files not in sub image configuration file
#
my %offsetref;
my $forceoffset;
forced_offset: foreach $forceoffset (@offsets) {

    my ($filename, $offset) =  ($forceoffset =~ /([^,]+),([^\s]+)/);

    my $found = 0;
    my $tocitem;
    foreach $tocitem (@toc) {
        if ($tocitem->{tocname} eq $filename) {
            die "Offset of $filename already defined" unless !defined $tocitem->{start};
            $tocitem->{start} = hex $offset;
            next forced_offset;
        }
    }
}

# ATV Sorting not needed for now
#@toc = sort bystart @toc;

#
# Process all parameters
#
while ($#ARGV >= 0) {
    
    my $cur = shift @ARGV;

    my $tocitem;
    my $curtocname;

    if ($cur =~ /,/) {
        ($curtocname) = ($cur =~ /,(.+)/);
        $cur =~ s/,.+//;
    } else {
        $curtocname = strippath($cur);
    }

    foreach $tocitem (@toc) {

        die "Duplicate entry for $cur\n" unless (! ($tocitem->{tocname} eq $curtocname));
    }

    die "Can't open $cur\n" unless (-e $cur);

    my $contentlength = -s $cur;

    push @toc, {tocname       => $curtocname,
                filename      => $cur,
                contentlength => $contentlength};
}

#
# Sanity check 
#
if (defined $tocrange->{end}) {
    die "TOC range too small\n" unless (($tocrange->{end} / (length tocentry("", 0,0,0,0))) >= ($#toc + 1));
} else {
    $tocrange->{end} = (length tocentry("", 0,0,0,0)) * ($#toc + 2);
}

my @payloadrange;

push @payloadrange, {start => 0,
                     end   => 0xFFFFFFFF};

carve(0, $tocrange->{end});

#
# Remove hard-coded areas from free payload area
#
my $tocitem;
foreach $tocitem (@toc) {
    if (defined $tocitem->{start}) {
        if (defined $tocitem->{reserved_size}) {
            carve($tocitem->{start},
                  $tocitem->{reserved_size});
        } else {
            my $contentlength;

            if (defined $tocitem->{content}) {
                $contentlength = length $tocitem->{content};
            } else {
                
            }

            carve($tocitem->{start},
                  $contentlength);
        }
    }
}

#
# Allocate area for the rest
#
foreach $tocitem (@toc) {
    if (!defined $tocitem->{start}) {
        if (defined $tocitem->{reserved_size}) {
            $tocitem->{start} = grab($tocitem->{reserved_size});
        } else {
            if (defined $tocitem->{content}) {
                $tocitem->{start} = grab(length $tocitem->{content});
            } else {
                $tocitem->{start} = grab($tocitem->{contentlength});
            }
        }
#       printf ::stderr ("Grabbed 0x%08X for %s\n", $tocitem->{start}, $tocitem->{tocname});
    }
}

#
# Check for command line load addresses
#
    my $loadreq;
loadreq: foreach $loadreq (@loadaddrs) {

    my ($reqname, $reqaddr) = ($loadreq =~ /^([^,]+),(.+)$/);

    $reqaddr = eval $reqaddr;

#    printf("Checking %s 0x%08X\n", $reqname, $reqaddr);

    foreach $tocitem (@toc) {
        if ($tocitem->{tocname} eq $reqname) {
            die "Multiple load addresses for $reqname \n" unless ! $tocitem->{load};

            $tocitem->{load} = $reqaddr;
            next loadreq;
        }
    }
    die "Command line load address specified for non-existent file $reqname\n";
}

#
# Create TOC
#
my $payload = "";
foreach $tocitem (sort {$a->{start} <=> $b->{start}} @toc) {
    $payload .= verbose_tocentry($tocitem->{tocname},
                                 $tocitem->{start},
                                 (defined $tocitem->{contentlength}) ? $tocitem->{contentlength} : length $tocitem->{content},
                                 $tocitem->{flags},
                                 $tocitem->{load},
                                 $tocitem->{optsize});
}

if (defined $output) {
    open(STDOUT, ">$output") or die "Can't open \"" . $output . "\" for writing\n";
}

print $payload;

my $payloadlen = length $payload;

#
# Create payload
#
foreach $tocitem (sort {$a->{start} <=> $b->{start}} @toc) {

    if ($payloadlen < $tocitem->{start}) {
        my $pad = pack("C", 0xFF) x ($tocitem->{start} - ($payloadlen));
        $payloadlen += length $pad;
        print $pad;
    }

    if ((defined $tocitem->{optional}) && (0 == length $tocitem->{content})) {
        next;
    }

    if (defined $tocitem->{content}) {
        print $tocitem->{content};
        $payloadlen += length $tocitem->{content};
    } else {
        system ("cat $tocitem->{filename}");
        $payloadlen += -s $tocitem->{filename};
    }
}

print pack("C", 0xFF) x (alignup($payloadlen) - $payloadlen);

#
# Print payload
# 
#print $payload;

#
# Fail if disk full
#
close(STDOUT)  || die "Can't close stdout: $!\n";

###############################################################################
#
#   HELPER FUNCTIONS
#
###############################################################################

#
# Process one sub image config file
#
sub process_sub_image_conf_file {
    my ($subimageconf, $tocrangeref) = @_;

    my @toc;

    open(SUB, "<$subimageconf") or die "Can't open $subimageconf\n";

    if (defined $optverbose) {
        printf ::stderr ("Reading $subimageconf\n");
    }

    while (<SUB>) {

        if (/^\s*;/) {
            next;
        }

        if (my ($tocstart, $tocend) = ($_ =~ /^TOC\s*\=?\s*:\s*([0-9a-f]+)\s*\-\s*([0-9a-f]+)/i)) {
            ${$tocrangeref}->{start} = hex $tocstart;
            ${$tocrangeref}->{end}   = (hex $tocend) + 1;
            ${$tocrangeref}->{end}   &= ~1;
            
            if (defined $optverbose) {
                printf ::stderr ("TOC range defined: 0x%08X--0x%08X\n", ${$tocrangeref}->{start}, ${$tocrangeref}->{end});
            }

            next;
        }

        if (my ($tocname, $filename, $start, $end, $rest) =
            ($_ =~ /^([^\s]+)\s*\=\s*([^\s]+)\s*:?\s*([0-9a-f]+)?\s*\-?\s*([0-9a-f]+)?\s*(.+)?/i)) {

            die "Can't open $filename\n" unless (-e $filename);

            my $contentlength = -s $filename;

            my $reserved_size;

            if (defined $optverbose) {
                printf ::stderr (" TOC entry %s (file %s)\n", $tocname, $filename);

                if (defined $start) {
                    printf ::stderr ("     start address 0x%08X\n", eval $start);
                }

                printf ::stderr ("     length        0x%08X\n", eval $contentlength);
            }

            if (defined $end) {
           
                if (defined $optverbose) {
                    printf ::stderr ("     end   address 0x%08X\n", eval $end);
                }

                $reserved_size = 1 + (hex $end) - (hex $start);
                $reserved_size &= ~1; # Kludge - allow small errors in the conf file
            } else {
                $reserved_size = $contentlength;
            }

            die "area reserved for $tocname ($filename) too small\n" unless ($reserved_size >= $contentlength);

            my $load;
            my $flags;

            if (defined $rest) {
                ($load)  = ($rest =~ /LOAD_ADDRESS\s*\=\s*([0-9a-f]+)/i);
                ($flags) = ($rest =~ /TOC_FLAGS\s*\=\s*([0-9a-f]+)/i);
            }

            if (defined $flags) {
                $flags = hex $flags;
            } else {
                $flags = 0;
            } 

            if (defined $load) {
                $load = hex $load;

                if (defined $optverbose) {
                    printf ::stderr ("     load  address 0x%08X\n", eval $load);
                }
            } else {
                $load = 0;
            } 

            if (defined $start) {

                push @toc, {tocname       => $tocname,
                            filename      => $filename,
                            start         => hex $start,
                            contentlength => $contentlength,
                            reserved_size => $reserved_size,
                            flags         => $flags,
                            load          => $load};
            } else {

                push @toc, {tocname       => $tocname,
                            filename      => $filename,
                            contentlength => $contentlength,
                            reserved_size => $reserved_size,
                            flags         => $flags,
                            load          => $load};
            }
        }
    }

    if (defined $optverbose) {
        printf ::stderr ("File $subimageconf read\n");
    }

    return @toc;
}

sub verbose_tocentry {
    my($name, $offset, $size, $flags, $load, $optsize) = @_;

    if ((defined $optsize) && (eval $optsize)) {

        $optsize = eval $optsize;

        die "Optional file real size > optional size\n" unless ($size < $optsize);

        $size = $optsize;
    }

    if (defined $optverbose) {
        printf ::stderr ("TOC: %-12s @ 0x%08X--0x%08X %-16s %-16s\n", $name, $offset, $offset + $size - 1, $flags ? sprintf("Flags 0x%08X", $flags) : "", $load ? sprintf("Load  0x%08X", $load ) : "");
    }

    return tocentry ($name, $offset, $size, $flags, $load);
}

sub tocentry {
    my($name, $offset, $size, $flags, $load) = @_;

    $name .= pack("c", 0) x 12;

    if (!defined $flags) {$flags = 0;}
    if (!defined $load)  {$load  = 0;}

    return (pack("V", $offset) . 
            pack("V", $size)   . 
            pack("V", $flags)  . 
            pack("V", 0)       .
            pack("V", $load)   .
            substr($name, 0, 12));
}

#
# Helper for sorting TOC entries by address
#
sub bystart {
    if (!defined $a->{start} && !defined $b->{start}) {return ($a->{tocname} cmp $b->{tocname});}
    if ( defined $a->{start} && !defined $b->{start}) {return (1 <=> 2);}
    if (!defined $a->{start} &&  defined $b->{start}) {return (2 <=> 1);}

    return ($a->{start} <=> $b->{start});
}

sub strippath {
    my ($filename) = @_;

    $filename =~ s/.+\///;
    return $filename;
}

sub alignup {
    my ($start) = @_;

    if ($start & ($align - 1)) {
        return $start + ($align - ($start & ($align - 1)));
    }

    return $start;
}

#
# Remove a fixed address range from the payload range
#
sub carve {
    my ($start, $size) = @_;

    my $payloadrange;

    foreach $payloadrange (@payloadrange) {
        if (($start <= $payloadrange->{start}) &&
            (($start + $size) > $payloadrange->{start})) {
            $payloadrange->{start} = ($start + $size);
            last;
        }

        if (($start > $payloadrange->{start}) &&
            (($start + $size) < $payloadrange->{end})) {

            my $newend = $payloadrange->{end};

            $payloadrange->{end} = $start;

            push @payloadrange, {start => ($start + $size),
                                 end   => $newend};
            last;
        }
    }

    @payloadrange = sort { $a->{start} <=> $b->{start}}  @payloadrange;

}

#
# Allocate $size bytes from the payload range
#
sub grab {
    my($size) = @_;

    my $payloadrange;
    foreach $payloadrange (@payloadrange) {

        my $startcandidate = alignup($payloadrange->{start});

        if (($payloadrange->{end} - $startcandidate) >= $size) {
            carve($startcandidate, $size);
            return $startcandidate;
        }
    }

    die "Can't find an area of $size bytes\n";
}
