/*	i2c.c
 *
 * Copyright (C) 2012 Renesas Mobile Corp.
 * All rights reserved.
 *
 */


#include "i2c.h"
#include "cpg.h"
#include "tmu_api.h"

/* HP clock from I2C_Set_Hp() */
static I2C_HPCLK sHPClk = I2C_HPCLK_104MHZ;

/* CH from I2C_Set_Ch() */
static I2C_CH sCh = I2C_CH_IIC0;

/* Internal function Prototypes */
static void I2C_Force_Reset(void);
static void I2C_Force_Reset_exclusive(I2C_CH ch);
static RC I2C_Initialize(I2C_REG* reg);
static RC I2C_Finalize(I2C_REG reg);
static RC I2C_Wait(I2C_REG reg, uchar check_bit);

/**
 * I2C_Init - Initialize I2C module
 * @return None
 */
void I2C_Init(void)
{
	/* IIC0 module initialize */
	*CPG_SMSTPCR1 &= ~CPG_SMSTPCR1_116;
	*CPG_SRCR1 &= ~CPG_SRCR1_SRT116;

	/* module disable */
	*(ICCR0) &= 0x7F;
	// *(ICCR1) &= 0x7F;

	/* module enable */
	*(ICCR0) |= 0x80;

	/* PAD_RTL reset */
	while( *(ICASTART0) != 0x10 )
	{
		*(ICASTART0) = 0x10;
	}

	/* Cancels the reset of PAD_RTL  */
	while( *(ICASTART0) != 0x00 )
	{
		*(ICASTART0) = 0x00;
	}

	/* module disable */
	*(ICCR0) &= 0x7F;

	/* I2C clock setting processing */
	I2C_Set_Hp(I2C_HPCLK_104MHZ);
	
	I2C_Force_Reset();

	/* I2C ch setting processing */
	I2C_Set_Ch(I2C_CH_IIC0);
	
	return ;
}

/**
 * I2C_Force_Reset - Force Reset I2C module
 * @return None
 */
void I2C_Force_Reset(void)
{

	I2C_Force_Reset_exclusive(I2C_CH_IIC0);

}

/**
 * I2C_Force_Reset_exclusive - Force Reset exclusive I2C module
 * @return None
 */
void I2C_Force_Reset_exclusive(I2C_CH ch)
{
	I2C_REG reg;
	int i=0;
	volatile uchar work;
	volatile int ret;
	volatile uchar tmp_icsr;

	I2C_Set_Ch(ch);

	/* 0xFF data transfer */
	work = 0xFF;

	/* until 1-8 times data transfer is I2C force reset
	   9 times data transfer is stop condition setting */

	for(i=0; i<2; i++)
	{
		I2C_Initialize(&reg);
		*(reg.ICDR) = work;

		ret = I2C_Wait(reg, ICSR_DATA_WAIT);
		if(i < 1)
		{
			/* Should be wait for tLow spec time */
			/* tLow = Min:1.3us => wait 10us*/
			TMU_Wait_US(10);
			/* I2C force reset*/
			*(reg.ICCR) &= 0x7F;
		}
		else
		{
			*(reg.ICCR) = 0x90;
		}
	}

	/* clear wait interrupt factor */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);

	tmp_icsr = *(reg.ICSR);

	while(tmp_icsr & ICSR_DATA_BUSY)
	{
		/* wait */
		TMU_Wait_US(10);

		tmp_icsr = *(reg.ICSR);
	}

	*(reg.ICIC) = 0x00;
	*(reg.ICSR) = 0x00;
	*(reg.ICCR) &= 0x7F;
}

/**
 * I2C_Set_Hp - Set HP clock(52MHz/104MHz)
 * @return None
 */
void I2C_Set_Hp(I2C_HPCLK hpclk)
{
	sHPClk = hpclk;
	
	return ;
}


/**
 * I2C_Set_Ch - Set Ch(IIC2/IIC4)
 * @return None
 */
void I2C_Set_Ch(I2C_CH ch)
{
	sCh = ch;
	
	return ;
}


/**
 * I2C_Write - I2C 1byte write
 * @return I2C_SUCCESS     : Successful
 *         I2C_ERR_START   : I2C transmission start error
 *         I2C_ERR_TIMEOUT : I2C timeout error
 */
RC I2C_Write(uchar slave_addr, uchar register_addr, uchar w_data)
{
	RC ret;
	uchar work;
	I2C_REG reg;
	
	ret = I2C_Initialize(&reg);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* To transmit data, write data to ICDR. The DTE bit is then automatically cleared.
	   Data transmission starts when data is send to the internal transmit buffer.
	   The DTE bit in ICSR is then set to 1 again. */
	
	/* slave address */
    work = (((slave_addr << 1) + I2C_CMD_WRITE) & 0xFF);
	*(reg.ICDR) = work;
	
	/* If, due to a delay in ICDR or ICCE writing, processing is perfomed
	   continuously before and after generating the ACK bit, a DTE interrupt is generated,
	   which disables the software control for normal communication.
	   For this reason, modify ICDR and ICCR before generation the ACK bit.
	
	   ICDR and ICCR can be written before the ACK bit is generated by modifying them from the
	   occurrence of a WAIT interrupt until the WAIT interrupt source is cleared. */
	
	/* wait for slaveaddr(I2C_CMD_WRITE) sending */
	/* WAIT interrupt waiting */
	ret = I2C_Wait(reg, ICSR_DATA_WAIT);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* register address */
	*(reg.ICDR) = register_addr;
	
	/* Clearness of WAIT causes of interrupts */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);
	
	/* wait for register_addr */
	/* WAIT interrupt waiting */
	ret = I2C_Wait(reg, ICSR_DATA_WAIT);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* DATA Write */
	*(reg.ICDR) = w_data;
	
	/* Clearness of WAIT causes of interrupts */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);
	
	/* wait for write data */
	/* WAIT interrupt waiting */
	ret = I2C_Wait(reg, ICSR_DATA_WAIT);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* Clearness of WAIT causes of interrupts */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);
	
	/* To issue and generate the stop condition, 
	   write the final data to ICDR, then write H'90 to ICCR. */
	*(reg.ICCR) = ICCR_DATA_ICE_TRS;
	
	ret = I2C_Finalize(reg);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}

	return I2C_SUCCESS;
}


/**
 * I2c_Read - I2C 1Byte read
 * @return I2C_SUCCESS     : Successful
 *         I2C_ERR_START   : I2C transmission start error
 *         I2C_ERR_TIMEOUT : I2C timeout error
 */
RC I2C_Read(uchar slave_addr, uchar register_addr, uchar* r_data)
{
	RC ret;
	uchar work;
	I2C_REG reg;
	
	ret = I2C_Initialize(&reg);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* To transmit data, write data to ICDR. The DTE bit is then automatically cleared.
	   Data transmission starts when data is send to the internal transmit buffer.
	   The DTE bit in ICSR is then set to 1 again. */
	
	/* slave address */
    work = (((slave_addr << 1) + I2C_CMD_WRITE) & 0xFF);
	*(reg.ICDR) = work;
	
	/* If, due to a delay in ICDR or ICCE writing, processing is perfomed
	   continuously before and after generating the ACK bit, a DTE interrupt is generated,
	   which disables the software control for normal communication.
	   For this reason, modify ICDR and ICCR before generation the ACK bit.
	
	   ICDR and ICCR can be written before the ACK bit is generated by modifying them from the
	   occurrence of a WAIT interrupt until the WAIT interrupt source is cleared. */	
	
	/* wait for slaveaddr(I2C_CMD_WRITE) sending */
	/* WAIT interrupt waiting */
	ret = I2C_Wait(reg, ICSR_DATA_WAIT);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* register address */
	*(reg.ICDR) = register_addr;
	
	/* To issue and generate the retransmit condition, write the final data to ICDR, then write H'94 to ICCR.
	   DTE is not set to 1 from issuing the retransmit condition to generating the retransmit condition.
	   After the final data is transmitted, the retransmit condition is generated. */
	*(reg.ICCR) = ICCR_DATA_ICE_TRS_BBSY;
	
	/* DTE enabling interrupt */
	*(reg.ICIC) |= ICIC_DATA_DTEE;
	
	/* Clearness of WAIT causes of interrupts */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);
	
	/* wait for register_addr */
	/* WAIT interrupt waiting */
	ret = I2C_Wait(reg, ICSR_DATA_WAIT);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* Clearness of WAIT causes of interrupts */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);
	
	/***********************************************************************/
    /* Data read phase                                                     */
    /***********************************************************************/
	/* wait for START Condition for READ */
	/* DTE waiting */
	ret = I2C_Wait(reg, ICSR_DATA_DTE);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* WAIT enabling interrupt */
	*(reg.ICIC) |= ICIC_DATA_WAITE;
	
	/* DTE interrupt inhibit */
	*(reg.ICIC) &= ~(ICIC_DATA_DTEE);
	
	/* slave address */
	work = (((slave_addr << 1) + I2C_CMD_READ) & 0xFF) ;
	*(reg.ICDR) = work;
	
	/* wait for slaveaddr(I2C_CMD_READ) sending */
	/* WAIT waiting */
	ret = I2C_Wait(reg, ICSR_DATA_WAIT);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* To change from transmission to reception, write H'81 to ICCR until the completion of transmission of
	   the final data. At this time, if writing to ICCR is delayed, use a WAIT interrupt to write to ICCR
	   until the completion of transmission of the final data. */
	*(reg.ICCR) = ICCR_DATA_ICE_SCP;
	
	/* Clearness of WAIT causes of interrupts */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);
	
	/* wait for read data */
	/* WAIT waiting */
	ret = I2C_Wait(reg, ICSR_DATA_WAIT);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* DTE enabling interrupt */
	*(reg.ICIC) |= ICIC_DATA_DTEE;
	
	/* Stop Condition */
	*(reg.ICCR) = ICCR_DATA_ICE_RACK;
	
	/* Clearness of WAIT causes of interrupts */
	*(reg.ICSR) &= ~(ICSR_DATA_WAIT);
	
	/* wait for moving read data to ICDR */
	/* DTE waiting */
	ret = I2C_Wait(reg, ICSR_DATA_DTE);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* WAIT interrupt inhibit */
	*(reg.ICIC) &= ~(ICIC_DATA_WAITE);
	
	/* Default DATA Read */
	*r_data = *(reg.ICDR);
	
	ret = I2C_Finalize(reg);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	return I2C_SUCCESS;
}


/**
 * I2C_Initialize - Initialize process(internal)
 * @return I2C_SUCCESS     : Successful
 *         I2C_ERR_START    : Initialize error
 *         I2C_ERR_TIMEOUT : Timeout error
 */
RC I2C_Initialize(I2C_REG* reg)
{
	RC ret;
	
	if (sCh == I2C_CH_IIC0)
	{
		/* check SMSTPCR1 MSTP116 (Controls clock supply to IIC0) */
		if ((*CPG_SMSTPCR1 & CPG_SMSTPCR1_116) != 0)
		{
			return I2C_ERR_START;
		}
	
		/* check SRCR1 SRT116 (Issues the reset to IIC0) */
		if ((*CPG_SRCR1 & CPG_SRCR1_SRT116) != 0)
		{
			return I2C_ERR_START;
		}		
		
		/* I2C register setting for IIC0 */
		reg->ICDR = ICDR0;
		reg->ICCR = ICCR0;
		reg->ICSR = ICSR0;
		reg->ICIC = ICIC0;
		reg->ICCL = ICCL0;
		reg->ICCH = ICCH0;
		reg->ICASTART = ICASTART0;
	}
	else
	{
		return I2C_ERR_START;
	}
	
	/* I2C module registers are all initialized */
	*(reg->ICCR) = REG_8BIT_CLEAR;
	
	/* ICCR.ICE[7] I2C enable */
	*(reg->ICCR) |= ICCR_DATA_ICE;
	
	if (sHPClk == I2C_HPCLK_52MHZ)
	{
		*(reg->ICCL) = ICCL_DATA_52MHZ;
		*(reg->ICCH) = ICCH_DATA_52MHZ;
	}
	else
	{
		*(reg->ICCL) = ICCL_DATA_104MHZ;
		*(reg->ICCH) = ICCH_DATA_104MHZ;
	}
	
	/* WAIT DTE Enabling interrupt */
	*(reg->ICIC) |= ICIC_DATA_WAITE_DTEE;
	
	/* Write H'94 in ICCR to issue the start condition. The DTE bit in ICSR is then set to 1. */
	*(reg->ICCR) = ICCR_DATA_ICE_TRS_BBSY;
	
	/* DTE waiting */
	ret = I2C_Wait(*reg, ICSR_DATA_DTE);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* DTE interrupt inhibit */
	*(reg->ICIC) &= ~(ICIC_DATA_DTEE);
	
	return I2C_SUCCESS;
}


/**
 * I2C_Finalize - Finalize process(internal)
 * @return I2C_SUCCESS     : Successful
 *         I2C_ERR_TIMEOUT : Timeout error
 */
RC I2C_Finalize(I2C_REG reg)
{
	RC ret;
	
	/* Waiting of bus open */
	ret = I2C_Wait(reg, ICSR_DATA_SCLM_SDAM);
	if (ret != I2C_SUCCESS)
	{
		return ret;
	}
	
	/* Clearness of interrupt status register */
	*(reg.ICSR) = REG_8BIT_CLEAR;
	
	/* Clearness of interrupt control register */
	*(reg.ICIC) = REG_8BIT_CLEAR;
	
	/* ICCR.ICE(Bit7) = 0 */
	*(reg.ICCR) &= ~(ICCR_DATA_ICE);
	
	/* WAIT */
	TMU_Wait_US(I2C_RW_END_WAIT_LOOP);
	
	return I2C_SUCCESS;
}


/**
 * I2C_Wait - Wait process
 * @return I2C_SUCCESS     : Successful
 *         I2C_ERR_TIMEOUT : I2C timeout error
 */
RC I2C_Wait(I2C_REG reg, uchar check_bit)
{
	volatile ulong count = 0;
	volatile uchar temp_icsr;
	
	temp_icsr = *(reg.ICSR);
	
	while (check_bit != (check_bit & temp_icsr))
	{
		temp_icsr = *(reg.ICSR);
		
		/* WAIT for ACK DTE */
		/* 10us wait */
		TMU_Wait_US(10);
		
		count++;
		if(count >= ICSR_TIMEOUT_COUNT)
		{
			return I2C_ERR_TIMEOUT;
		}
	}
	
	return I2C_SUCCESS;
}
