/*
 * Copyright (C) 2012 Renesas Mobile Corporation
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301, USA.
 */

#include <i2c/r_mobile_i2c.h>

/* I2C setting value */
#define REG_8BIT_CLEAR			0x00	/* Bit Clear */
#define ICSR0_DATA_DTE			0x01	/* ICSR0 - DTE(0 Bit) */
#define ICSR0_DATA_WAIT			0x02	/* ICSR0 - WAIT(1 Bit) */
#define ICSR0_DATA_SCLM_SDRAM	0xC0	/* ICSR0 - SCLM,SDRAM(7-6 Bit) */
#define ICIC0_DATA_DTEE			0x01	/* ICIC0 - DTEE(0 Bit) */
#define ICIC0_DATA_WAITE		0x02	/* ICIC0 - WAITE(1 Bit) */
#define ICIC0_DATA_WAITE_DTEE	0x03	/* ICIC0 - WAITE,DTEE(1,0 Bit) */
#define ICCR0_DATA_ICE			0x80	/* ICCR0 - ICE(7 Bit) */
#define ICCR0_DATA_ICE_SCP		0x81	/* ICCR0 - ICE,SCP(7,0 Bit) */
#define ICCR0_DATA_ICE_TRS		0x90	/* ICCR0 - ICE,TRS(7,4 Bit) */
#define ICCR0_DATA_ICE_TRS_BBSY	0x94	/* ICCR0 - ICE,TRS,BBSY(7,4,2 Bit) */
#define ICCR0_DATA_ICE_RACK		0xC0	/* ICCR0 - ICE,RACK(7,6 Bit) */
#define ICCL0_DATA_52MHZ		0x24	/* ICCL0 value when HP clock=52MHz */
#define ICCH0_DATA_52MHZ		0x1D	/* ICCH0 value when HP clock=52MHz */
#define ICCL0_DATA_104MHZ		0x48	/* ICCL0 value when HP clock=104MHz */
#define ICCH0_DATA_104MHZ		0x3A	/* ICCH0 value when HP clock=104MHz */
#define GPIO_SELECT_FUNCTION2	0x12	/* PORTnCR - OE,PTMD(4,2 Bit) */


/* Data transfer direction setting value */
#define I2C_CMD_READ			1		/* Data demand (reading) */
#define I2C_CMD_WRITE			0		/* Transmission (writing) */


/* define for ICSR0 reference */
#define ICSR0_WAIT_LOOP_10US	13		/* 10us wait */
#define ICSR0_TIMEOUT_COUNT		10000		/* maximum reference number of times */
#define I2C_RW_END_WAIT_LOOP	0x1000	/* wait in i2c_1byte_write/i2c_1byte_read end */


/* HP clock from I2C_Set_Hp() */
static I2C_HPCLK sHPClk = I2C_HPCLK_104MHZ;


/* Internal function Prototypes */
static int i2c_initialize(void);
static int i2c_finalize(void);
static int i2c_wait(uchar check_bit);


/*
 * I2C_Init - Initialize I2C module
 * @return None
 */
void i2c_init(void)
{
	/* IIC2 module initialize */
	writeb(readl(SMSTPCR1) & (~SMSTPCR1_116), SMSTPCR1);
	writeb(readl(SRCR1) & (~SRCR1_SRT116), SRCR1);
	
	/* I2C clock setting processing */
	i2c_set_Hp(I2C_HPCLK_104MHZ);
}


/*
 * I2C_Set_Hp - Set HP clock(52MHz/104MHz)
 * @return None
 */
void i2c_set_Hp(I2C_HPCLK hpclk)
{
	sHPClk = hpclk;
}


/*
 * I2C_Write - I2C 1byte write
 * @return 0     : Successful
 *         EBUSY   : I2C transmission start error
 *         ETIMEDOUT : I2C timeout error
 */
int i2c_write(uchar slave_addr, uchar register_addr, uchar w_data)
{
	int ret;
	uchar work;
	
	ret = i2c_initialize();
	if (ret){
		return ret;
	}
	
	
	/* To transmit data, write data to ICDR. The DTE bit is then automatically cleared.
	   Data transmission starts when data is send to the internal transmit buffer.
	   The DTE bit in ICSR is then set to 1 again. */
	
	/* slave address */
    work = (((slave_addr << 1) + I2C_CMD_WRITE) & 0xFF);
	
	writeb(work, ICDR0);
	
	/* If, due to a delay in ICDR or ICCE writing, processing is perfomed
	   continuously before and after generating the ACK bit, a DTE interrupt is generated,
	   which disables the software control for normal communication.
	   For this reason, modify ICDR and ICCR before generation the ACK bit.
	
	   ICDR and ICCR can be written before the ACK bit is generated by modifying them from the
	   occurrence of a WAIT interrupt until the WAIT interrupt source is cleared. */
	
	/* wait for slaveaddr(I2C_CMD_WRITE) sending */
	
	/* WAIT interrupt waiting */
	ret = i2c_wait(ICSR0_DATA_WAIT);
	if (ret){
		return ret;
	}
	
	/* register address */
	writeb(register_addr, ICDR0);
	
	/* Clearness of WAIT causes of interrupts */
	writeb(readb(ICSR0) & (~ICSR0_DATA_WAIT), ICSR0);
	
	/* wait for register_addr */
	/* WAIT interrupt waiting */
	ret = i2c_wait(ICSR0_DATA_WAIT);
	if (ret){
		return ret;
	}
	
	/* DATA Write */
	writeb(w_data, ICDR0);
	
	/* Clearness of WAIT causes of interrupts */
	writeb(readb(ICSR0) & (~ICSR0_DATA_WAIT), ICSR0);
	
	/* wait for write data */
	/* WAIT interrupt waiting */
	ret = i2c_wait(ICSR0_DATA_WAIT);
	if (ret){
		return ret;
	}
	
	/* Clearness of WAIT causes of interrupts */
	writeb(readb(ICSR0) & (~ICSR0_DATA_WAIT), ICSR0);
	
	/* To issue and generate the stop condition, 
	   write the final data to ICDR, then write H'90 to ICCR. */
	writeb(ICCR0_DATA_ICE_TRS, ICCR0);
	
	ret = i2c_finalize();
	if (ret){
		return ret;
	}
	
	return 0;
}


/*
 * I2c_Read - I2C 1Byte read
 * @return 0     : Successful
 *         EBUSY   : I2C transmission start error
 *         ETIMEDOUT : I2C timeout error
 */
int i2c_read(uchar slave_addr, uchar register_addr, uchar* r_data)
{
	int ret;
	uchar work;
	
	ret = i2c_initialize();
	if (ret){
		return ret;
	}
	
	/* To transmit data, write data to ICDR. The DTE bit is then automatically cleared.
	   Data transmission starts when data is send to the internal transmit buffer.
	   The DTE bit in ICSR is then set to 1 again. */
	
	/* slave address */
    work = (((slave_addr << 1) + I2C_CMD_WRITE) & 0xFF);
	
	writeb(work, ICDR0);
	
	/* If, due to a delay in ICDR or ICCE writing, processing is perfomed
	   continuously before and after generating the ACK bit, a DTE interrupt is generated,
	   which disables the software control for normal communication.
	   For this reason, modify ICDR and ICCR before generation the ACK bit.
	
	   ICDR and ICCR can be written before the ACK bit is generated by modifying them from the
	   occurrence of a WAIT interrupt until the WAIT interrupt source is cleared. */	
	
	/* wait for slaveaddr(I2C_CMD_WRITE) sending */
	/* WAIT interrupt waiting */
	ret = i2c_wait(ICSR0_DATA_WAIT);
	if (ret){
		return ret;
	}
	
	/* register address */
	writeb(register_addr, ICDR0);
	
	/* To issue and generate the retransmit condition, write the final data to ICDR, then write H'94 to ICCR.
	   DTE is not set to 1 from issuing the retransmit condition to generating the retransmit condition.
	   After the final data is transmitted, the retransmit condition is generated. */
	writeb(ICCR0_DATA_ICE_TRS_BBSY, ICCR0);
	
	/* DTE enabling interrupt */
	writeb(readb(ICIC0) | (ICIC0_DATA_DTEE), ICIC0);
	
	/* Clearness of WAIT causes of interrupts */
	writeb(readb(ICSR0) & (~ICSR0_DATA_WAIT), ICSR0);
	
	/* wait for register_addr */
	/* WAIT interrupt waiting */
	ret = i2c_wait(ICSR0_DATA_WAIT);
	if (ret){
		return ret;
	}
	
	/* Clearness of WAIT causes of interrupts */
	writeb(readl(ICSR0) & (~ICSR0_DATA_WAIT), ICSR0);
	
	/***********************************************************************/
    /* Data read phase                                                     */
    /***********************************************************************/
	/* wait for START Condition for READ */
	/* DTE waiting */
	ret = i2c_wait(ICSR0_DATA_DTE);
	if (ret){
		return ret;
	}
	
	/* WAIT enabling interrupt */
	writeb(readb(ICIC0) | (ICIC0_DATA_WAITE), ICIC0);

	/* DTE interrupt inhibit */
	writeb(readb(ICIC0) & (~ICIC0_DATA_DTEE), ICIC0);
	
	/* slave address */
	work = (((slave_addr << 1) + I2C_CMD_READ) & 0xFF) ;
	writeb(work, ICDR0);
	
	/* wait for slaveaddr(I2C_CMD_READ) sending */
	/* WAIT waiting */
	ret = i2c_wait(ICSR0_DATA_WAIT);
	if (ret){
		return ret;
	}
	
	/* To change from transmission to reception, write H'81 to ICCR until the completion of transmission of
	   the final data. At this time, if writing to ICCR is delayed, use a WAIT interrupt to write to ICCR
	   until the completion of transmission of the final data. */
	writeb(ICCR0_DATA_ICE_SCP, ICCR0);
	
	/* Clearness of WAIT causes of interrupts */
	writeb(readb(ICSR0) & (~ICSR0_DATA_WAIT), ICSR0);
	
	/* wait for read data */
	/* WAIT waiting */
	ret = i2c_wait(ICSR0_DATA_WAIT);
	if (ret){
		return ret;
	}
	
	/* DTE enabling interrupt */
	writeb(readb(ICIC0) | (ICIC0_DATA_DTEE), ICIC0);
	
	/* Stop Condition */
	writeb(ICCR0_DATA_ICE_RACK, ICCR0);
	
	/* Clearness of WAIT causes of interrupts */
	writeb(readb(ICSR0) & (~ICSR0_DATA_WAIT), ICSR0);

	/* wait for moving read data to ICDR0 */
	/* DTE waiting */
	ret = i2c_wait(ICSR0_DATA_DTE);
	if (ret){
		return ret;
	}
	
	/* WAIT interrupt inhibit */
	writeb(readb(ICIC0) & (~ICIC0_DATA_WAITE), ICIC0);

	/* Default DATA Read */
	*r_data = readb(ICDR0);
	
	/* udelay(5);*/
	
	ret = i2c_finalize();
	if (ret){
		return ret;
	}
	
	return 0;
}


/*
 * i2c_initialize - Initialize process(internal)
 * @return 0     : Successful
 *         EBUSY    : Initialize error
 *         ETIMEDOUT : Timeout error
 */
int i2c_initialize(void)
{
	int ret;
	
	/* check SMSTPCR1 MSTP116 (Controls clock supply to IIC0) */
	if ((readl(SMSTPCR1) & SMSTPCR1_116) != 0){
		return EBUSY;
	}
	
	/* check SRCR1 SRT116 (Issues the reset to IIC0) */
	if ((readl(SRCR1) & SRCR1_SRT116) != 0){
		return EBUSY;
	}
	
	
	/* Set bits in ICCL, ICCH, and ICIC according to the operating mode. */ 
	writeb(GPIO_SELECT_FUNCTION2, GPIO_PORT84CR);
	writeb(GPIO_SELECT_FUNCTION2, GPIO_PORT85CR);
	
	/* I2C module registers are all initialized */
	writeb(REG_8BIT_CLEAR, ICCR0);
	
	/* ICCR.ICE[7] I2C enable */
	writeb(readb(ICCR0) | ICCR0_DATA_ICE, ICCR0);
	if (sHPClk == I2C_HPCLK_52MHZ)
	{
		writeb(ICCL0_DATA_52MHZ, ICCL0);
		writeb(ICCH0_DATA_52MHZ, ICCH0);
	}
	else
	{
		writeb(ICCL0_DATA_104MHZ, ICCL0);
		writeb(ICCH0_DATA_104MHZ, ICCH0);
	}
	
	/* WAIT DTE Enabling interrupt */
	writeb(readb(ICIC0) | ICIC0_DATA_WAITE_DTEE, ICIC0);
	
	/* Write H'94 in ICCR to issue the start condition. The DTE bit in ICSR is then set to 1. */
	writeb(ICCR0_DATA_ICE_TRS_BBSY, ICCR0);
	
	/* DTE waiting */
	ret = i2c_wait(ICSR0_DATA_DTE);
	if (ret){
		return ret;
	}
	
	/* DTE interrupt inhibit */
	writeb(readb(ICIC0) & (~ICIC0_DATA_DTEE), ICIC0);
	
	return 0;
}


/*
 * i2c_finalize - Finalize process(internal)
 * @return 0     : Successful
 *         ETIMEDOUT : Timeout error
 */
int i2c_finalize(void)
{
	int ret;
	ulong i;
	
	/* Waiting of bus open */
	ret = i2c_wait(ICSR0_DATA_SCLM_SDRAM);
	if (ret){
		return ret;
	}
	
	/* Clearness of interrupt status register */
	writeb(REG_8BIT_CLEAR, ICSR0);
	
	/* Clearness of interrupt control register */
	writeb(REG_8BIT_CLEAR, ICIC0);
	
	/* ICCR.ICE(Bit7) = 0 */
	writeb(readb(ICCR0) & (~ICCR0_DATA_ICE), ICCR0);
	
	/* WAIT */
	for (i = 0; i < I2C_RW_END_WAIT_LOOP; i++)
	{}
	
	return 0;
}


/**
 * i2c_wait - Wait process
 * @return 0     : Successful
 *         ETIMEDOUT : I2C timeout error
 */
int i2c_wait(uchar check_bit)
{
	ulong count = 0;
	ulong i;
	uchar temp_icsr;
	
	temp_icsr = readb(ICSR0);
	
	while (check_bit != (check_bit & temp_icsr))
	{
		temp_icsr = readb(ICSR0);
		
		/* WAIT for ACK DTE */
		for (i = 0; i < ICSR0_WAIT_LOOP_10US; i++)
		{
			/* 10us wait */
		}
		
		count++;
		if(count >= ICSR0_TIMEOUT_COUNT){
			return ETIMEDOUT;
		}
		
	}
	
	return 0;
}             

/*
 * i2c_r_mobile_read - Read process
 * @return 0     : Successful
 *         Other : Fail
 */
static int i2c_r_mobile_read(struct i2c_adapter *adapter, uchar register_addr,struct i2c_msg *msgs)
{
	unsigned int i;
	int result;
	
	/* read data */
	for (i = 0; i < msgs->len; i++) {
		result = i2c_read(msgs->addr, register_addr, &msgs->buf[i]);
		if (result){
			return -result;
		}
	}
	
	return 0;
}

/*
 * i2c_r_mobile_read - Write process
 * @return 0     : Successful
 *         Other : Fail
 */
static int i2c_r_mobile_write(struct i2c_adapter *adapter, uchar register_addr, struct i2c_msg *msgs)
{
	unsigned int i;
	int result;
	
	/* write data */
	for (i = 1; i < msgs->len; i++) {
		if(msgs->buf[i]){
			result = i2c_write(msgs->addr, register_addr, msgs->buf[i]);
			if (result){
				return -result;
			}
		}
	}
	
	return 0;
}

/**
 * r_mobile_mobile_i2c_xfer - Tranfer process
 * @return 0     : Successful
 *         Other : Fail
 */
static int r_mobile_mobile_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)
{
	unsigned int i;
	int result;
	
	for (i = 0; i < num; i++) {
		/* write/read data */
		if (msgs[i].flags & I2C_M_RD){
			result = i2c_r_mobile_read(adapter, msgs[0].buf[0], &msgs[i]);
		}else{
			result = i2c_r_mobile_write(adapter, msgs[0].buf[0], &msgs[i]);
		}
		if (result){
			goto fail;
		}
	}
	
fail:
	/* Stop I2C transfer */
	return (result < 0) ? result : num;
}

/*
 * r_mobile_mobile_i2c_probe - Probe process
 * @return 0     : Successful
 *         Other : Fail
 */
static int r_mobile_mobile_i2c_probe(struct device_d *pdev)
{
	struct r_mobile_mobile_i2c_data *i2c_r_mobile;
	struct i2c_platform_data *pdata;
	unsigned long base = pdev->map_base;
	int ret;
	
	u32 speed = 0;
	pdata = pdev->platform_data;

	i2c_r_mobile = kzalloc(sizeof(struct r_mobile_mobile_i2c_data), GFP_KERNEL);

	/* Setup i2c_r_mobile driver structure */
	i2c_r_mobile->adapter.master_xfer = r_mobile_mobile_i2c_xfer;
	i2c_r_mobile->adapter.nr = pdev->id;
	i2c_r_mobile->adapter.dev = pdev;

	/* Set up clock divider */
	if (pdev->platform_data != NULL){
		speed = *(u32 *)pdev->platform_data;
	}else{
		speed = NORMAL_SPEED;	/* Default speed */
	}

	i2c_r_mobile->speed = speed;
	i2c_r_mobile->base = (void*)pdev->map_base;

	/* Set up chip registers to defaults */
	i2c_init();

	/* Add I2C adapter */
	ret = i2c_add_numbered_adapter(&i2c_r_mobile->adapter);
	if (ret < 0) {
		dev_err(pdev, "registration failed\n");
		goto fail;
	}

	return 0;

fail:
	kfree(i2c_r_mobile);
	return ret;
}

static struct driver_d r_mobile_mobile_i2c_driver = {
	.probe		= r_mobile_mobile_i2c_probe,
	.name		= "r_mobile_i2c",
};

/* I2C may be needed to bring up other drivers */
static int __init r_mobile_mobile_i2c_init_driver(void)
{
	return register_driver(&r_mobile_mobile_i2c_driver);
}
device_initcall(r_mobile_mobile_i2c_init_driver);
