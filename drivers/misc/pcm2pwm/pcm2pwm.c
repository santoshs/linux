/*
 * /drivers/misc/pcm2pwm/pcm2pwm.c
 *
 * Copyright (C) 2011-2012 Renesas Mobile Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/wakelock.h>
#include <linux/pm_runtime.h>
#include <linux/platform_device.h>
#include <linux/err.h>
#include <linux/clk.h>
#include <linux/io.h>
#include <linux/ioport.h>
#include <linux/gpio.h>
#include <linux/fs.h>
#include <mach/hardware.h>
#include <mach/r8a7373.h>
#include <linux/sh_dma.h>
#include <linux/dmaengine.h>
#include <linux/pcm2pwm.h>
#include <linux/dma-direction.h>
#include <linux/dma-mapping.h>

#ifdef DEBUG_PCM2PWM
#include <linux/uaccess.h>
#include <linux/miscdevice.h>
#endif /* DEBUG_PCM2PWM */
/* function prototype */
static int __init pcm2pwm_pf_init(void);
static void __exit pcm2pwm_pf_exit(void);
static int __devexit pcm2pwm_pf_remove(struct platform_device *pdev);
static int pcm2pwm_pf_probe(struct platform_device *pdev);
static int pcm2pwm_pf_resume(struct platform_device *pdev);
static int pcm2pwm_pf_suspend(struct platform_device *pdev, pm_message_t state);


static void dma_complete_cb(void *param);
static void dma_request_release(void);
static int dma_request_start(const void *buf, unsigned int buf_size);
static void work_dma_callback(struct work_struct *work);

#ifdef	DEBUG_PCM2PWM
static void pcm2pwm_create_debug_if(void);
static void pcm2pwm_delete_debug_if(void);
static ssize_t pcm2pwm_test_write(struct file *filp, const char __user *buf,
						size_t count, loff_t *ppos);
#endif	/* DEBUG_PCM2PWM */

#define CLKGEN_PHY_BASE_PHYS    (0xEC270000)
#define CLKGEN_REG_MAX     (0x0098)
#define CLKGEN_MAP_LEN     (CLKGEN_REG_MAX + 4)
#define CLKGSYSCTL         0
#define CLKGTIMSEL1        0x58
#define CLKGCPF0COM        0x18
#define CLKGPULSECTL       0x4
void __iomem *iomem_addr_clkgen = NULL

/* Enumurate */
enum pcm2pwm_state {
	PCM2PWM_CLOSE,
	PCM2PWM_OPEN,
	PCM2PWM_STOP,
	PCM2PWM_START
};

enum pcm2pwm_dma_state {
	DMA_STOP,
	DMA_TRANSMIT
};

/* Structure */
static struct platform_driver pcm2pwm_platform_driver = {
	.probe		= pcm2pwm_pf_probe,
	.remove		= __devexit_p(pcm2pwm_pf_remove),
	.suspend	= pcm2pwm_pf_suspend,
	.resume		= pcm2pwm_pf_resume,
	.driver		= {
		.name	= "pcm2pwm-renesas-sh_mobile",
		.owner	= THIS_MODULE,
	},
};

struct pcm2pwm_device {
	struct platform_device	*pdev;
	struct clk		*extal1_clk;
	struct clk		*extal2_clk;
	struct clk		*clk_gen;
	struct clk		*clk_supply;
	u16			*base_address;
	enum pcm2pwm_state	state;
        int			port_func;
	char 			*func_name;
};

struct pcm2pwm_dma_device {
	struct dma_chan *tx_chan;
	struct scatterlist *tx_sg;
	unsigned int tx_sg_len;
	int dma_state;
	const void *src;
	unsigned int buf_size;
	struct dma_async_tx_descriptor *tx_desc;
};

/* Macro */
#define UN_SUSPEND 0
#define SUSPEND    1

/* address of PWM_CONTROL register */
#define PCM2PWM_CTL(base) ((base) + 0x00)
/* address of PWM_DMA  register */
#define PCM2PWM_DMA(base) ((base) + 0x02)
/* address of PWM_COUNT register */
#define PCM2PWM_CNT(base) ((base) + 0x04)
/* address of PWM_PCM_FIFO buffer */
#define PCM2PWM_FIFO(base) ((base) + 0x80)

/* Variable */
static struct pcm2pwm_device pcm2pwm_platdevice = {
	.pdev = NULL,
	.extal1_clk = NULL,
	.extal2_clk = NULL,
	.clk_gen = NULL,
	.clk_supply = NULL,
	.base_address = NULL,
	.state = PCM2PWM_CLOSE,
	.extal1_clk = NULL,
};

struct pcm2pwm_dma_device pcm2pwm_dma_dev = {
	.tx_chan = NULL,
	.tx_sg = NULL,
	.tx_sg_len = 0,
	.dma_state = DMA_STOP,
	.src = NULL,
	.buf_size = 0,
	.tx_desc = NULL
};

static struct wake_lock pcm2pwm_wakelock;
static int pcm2pwm_suspend_state;
static struct mutex pcm2pwm_mutex;
static struct work_struct dma_work;
static struct pcm2pwm_port_info* pinfo;
/*
 * pcm2pwm_pf_probe:
 * @pdev: pointer to structure platform_device
 * return:
 *        0 if success.
 */
static int pcm2pwm_pf_probe(struct platform_device *pdev)
{
	pcm2pwm_platdevice.pdev = pdev;
	pinfo = pdev->dev.platform_data;

	pcm2pwm_platdevice.port_func = pinfo->port_func ;
	pcm2pwm_platdevice.func_name = pinfo->func_name ;


	pm_runtime_enable(&pdev->dev);
	return 0;
}

/*
 * pcm2pwm_pf_exit: Unregister TPU driver
 * return: void
 */
static void __exit pcm2pwm_pf_exit(void)
{
	platform_driver_unregister(&pcm2pwm_platform_driver);
#ifdef DEBUG_PCM2PWM
	pcm2pwm_delete_debug_if();
#endif /* DEBUG_PCM2PWM */
}

/*
 * pcm2pwm_pf_remove: This function is called when the device
 *						is removed from the system
 * @pdev	: a pointer of struct platform_device
 * return: 0
 */
static int __devexit pcm2pwm_pf_remove(struct platform_device *pdev)
{
	cancel_work_sync(&dma_work);
	pm_runtime_disable(&pdev->dev);
	return 0;
}

/*
 * pcm2pwm_pf_resume: Call-back function of platform driver in case of moving
 *			to resume state
 * @pdev:
 * return: 0
 */
static int pcm2pwm_pf_resume(struct platform_device *pdev)
{
	mutex_lock(&pcm2pwm_mutex); /* lock to prevent multiple thread */
	pcm2pwm_suspend_state = UN_SUSPEND;
	mutex_unlock(&pcm2pwm_mutex);
	return 0;
}

/*
 * pcm2pwm_pf_suspend: Call-back function of platform driver in case of moving
 *			to low-power state
 * @pdev
 * @state
 * return: 0
 */
static int pcm2pwm_pf_suspend(struct platform_device *pdev, pm_message_t state)
{
	/* lock to prevent multiple thread*/
	mutex_lock(&pcm2pwm_mutex);
	pcm2pwm_suspend_state = SUSPEND;
	cancel_work_sync(&dma_work);
	mutex_unlock(&pcm2pwm_mutex);
	return 0;
}

/*
 * pcm2pwm_open: Make PCM2PWM IP ready for using
 * return:
 *        0 if success, otherwise return negative value
 */
extern int pcm2pwm_open(void)
{
	struct platform_device *pdev;
	int ret;
	u32 val32;

	wake_lock(&pcm2pwm_wakelock); /* prevent suspend state */

	if (pcm2pwm_suspend_state == SUSPEND) { /* in suspend state */
		return  -EBUSY;
	}

	if (PCM2PWM_CLOSE != pcm2pwm_platdevice.state) {
		/* device already open */
		printk(KERN_ERR "[ERR]%s[%d] device is openning\n",
							__func__, __LINE__);
		return -EBUSY;
	}

	pdev = pcm2pwm_platdevice.pdev;

	ret = pm_runtime_get_sync(&pdev->dev);
	if (ret) {
		printk(KERN_ERR "[ERR]%s[%d]\n", __func__, __LINE__);
		return ret;
	}

	/* [W/A of ECR0292][Step1]
		Set value "0" to SRT523 bit including the SRCR5 register */
	val32 = __raw_readl(SRCR5);
	val32 = val32 & 0xFF7FFFFF;
	__raw_writel(val32, SRCR5);

	/* [W/A of ECR0292][Step2] Release module stop of PCM2PWM */
	pcm2pwm_platdevice.clk_supply = clk_get(&pdev->dev, NULL);
	if (IS_ERR(pcm2pwm_platdevice.clk_supply)) {
		printk(KERN_ERR "[ERR]%s[%d] get clk_supply failed\n",
							__func__, __LINE__);
		return -EINVAL;
	}

	ret = clk_enable(pcm2pwm_platdevice.clk_supply);
	if (ret) {
		printk(KERN_ERR "[ERR]%s[%d] enable clk_supply failed\n",
							__func__, __LINE__);
		return ret;
	}

	/* [W/A of ECR0292][Step3]
		Set value "1" to SRT523 bit including the SRCR5 register */
	val32 = __raw_readl(SRCR5);
	val32 = val32 | 0x00800000;
	__raw_writel(val32, SRCR5);

	/* request extal2 clock */
	pcm2pwm_platdevice.extal2_clk = clk_get(NULL, "extal2_clk");
	if (IS_ERR(pcm2pwm_platdevice.extal2_clk)) {
		printk(KERN_ERR "[ERR]%s[%d] get extal2_clk failed\n",
							__func__, __LINE__);
		return -EINVAL;
	}

	/* enable extal2 clock */
	ret = clk_enable(pcm2pwm_platdevice.extal2_clk);
	if (ret) {
		printk(KERN_ERR "[ERR]%s[%d] enable extal2 failed\n",
							__func__, __LINE__);
		return ret;
	}

	/* request extal1 clock */
	pcm2pwm_platdevice.extal1_clk = clk_get(NULL, "extal1_clk");
	if (IS_ERR(pcm2pwm_platdevice.extal1_clk)) {
		printk(KERN_ERR "[ERR]%s[%d] get extal1_clk failed\n",
							__func__, __LINE__);
		return -EINVAL;
	}

	/* enable extal1 clock */
	ret = clk_enable(pcm2pwm_platdevice.extal1_clk);
	if (ret) {
		printk(KERN_ERR "[ERR]%s[%d] enable extal1_clk failed\n",
							__func__, __LINE__);
		return ret;
	}

	/* request clkgen clock */
	pcm2pwm_platdevice.clk_gen = clk_get(NULL, "clkgen");
	if (IS_ERR(pcm2pwm_platdevice.clk_gen)) {
		printk(KERN_ERR "[ERR]%s[%d] get clkgen failed\n",
							__func__, __LINE__);
		return -EINVAL;
	}

	/* enable clkgen clock */
	ret = clk_enable(pcm2pwm_platdevice.clk_gen);
	if (ret) {
		printk(KERN_ERR "[ERR]%s[%d] enable clkgen failed\n",
						__func__, __LINE__);
		return ret;
	}

	/* map I/O memory */
	if (!request_mem_region(pdev->resource->start,
						resource_size(pdev->resource),
						pdev->resource->name)) {
		printk(KERN_ERR "[PWM ERR]%s[%d] IO memory is in use\n",
						__func__, __LINE__);
		return -EBUSY;
	}

	pcm2pwm_platdevice.base_address = (u16 *)ioremap_nocache(
			pdev->resource->start, resource_size(pdev->resource));
	if (pcm2pwm_platdevice.base_address == NULL) {
		printk(KERN_ERR "[PWM ERR]%s[%d] Unable to map IO memory\n",
						__func__, __LINE__);
		return -EBUSY;
	}

	/* map I/O memory clkgen*/
		iomem_addr_clkgen = ioremap_nocache(CLKGEN_PHY_BASE_PHYS,
					CLKGEN_MAP_LEN);
	if (iomem_addr_clkgen == NULL) {
		printk(KERN_ERR "[ERR]%s[%d] CLKGEN IO memory map failed\n",
							__func__, __LINE__);
		return -EINVAL;
	}

	pcm2pwm_platdevice.state = PCM2PWM_OPEN;

	return ret;
}
EXPORT_SYMBOL(pcm2pwm_open);

/*
 * pcm2pwm_close: Stop supplying power, clock.
 * return:
 *        0 if success, otherwise return negative value
 */
extern int pcm2pwm_close(void)
{
	struct platform_device *pdev;
	int ret;
	u32 val32;

	if (pcm2pwm_suspend_state == SUSPEND) { /* in suspend state */
		return -EBUSY;
	}

	if (PCM2PWM_CLOSE == pcm2pwm_platdevice.state) {
		/* device already close */
		printk(KERN_ERR "[ERR]%s[%d] device is closing\n",
					__func__, __LINE__);
		return -EINVAL;
	}

	pdev = pcm2pwm_platdevice.pdev;

	/* unmap I/O memory clkgen */
	iounmap((void *)iomem_addr_clkgen);

	/* unmap I/O memory */
	iounmap(pcm2pwm_platdevice.base_address);
	release_mem_region(pdev->resource->start,
					resource_size(pdev->resource));

	pcm2pwm_platdevice.base_address = NULL;

	/* [W/A of ECR0292] 3.
		Set value "0" to SRT523 bit including the SRCR5 register.*/
	val32 = __raw_readl(SRCR5);
	val32 = val32 & 0xFF7FFFFF;
	__raw_writel(val32, SRCR5);

	/* [W/A of ECR0292] 4. Set module stop of PCM2PWM */
	/* disable clock supply form pcm2pwm */
	if (pcm2pwm_platdevice.clk_supply) {
		clk_disable(pcm2pwm_platdevice.clk_supply);
		clk_put(pcm2pwm_platdevice.clk_supply);
		pcm2pwm_platdevice.clk_supply = NULL;
	}

	/* disable extal2 clock */
	if (pcm2pwm_platdevice.extal2_clk) {
		clk_disable(pcm2pwm_platdevice.extal2_clk);
		clk_put(pcm2pwm_platdevice.extal2_clk);
		pcm2pwm_platdevice.extal2_clk = NULL;
	}

	/* disable extal1 clock */
	if (pcm2pwm_platdevice.extal1_clk) {
		clk_disable(pcm2pwm_platdevice.extal1_clk);
		clk_put(pcm2pwm_platdevice.extal1_clk);
		pcm2pwm_platdevice.extal1_clk = NULL;
	}

	/* disable clkgen clock */
	if (pcm2pwm_platdevice.clk_gen) {
		clk_disable(pcm2pwm_platdevice.clk_gen);
		clk_put(pcm2pwm_platdevice.clk_gen);
		pcm2pwm_platdevice.clk_gen = NULL;
	}

	/* Disable A4MP */
	ret = pm_runtime_put_sync(&pdev->dev);
	if (ret) {
		printk(KERN_ERR "[PWM ERR]%s[%d] put PM sync unsuccessfully\n",
							__func__, __LINE__);
		return ret;
	}

	pcm2pwm_platdevice.state = PCM2PWM_CLOSE;

	wake_unlock(&pcm2pwm_wakelock);

	return ret;
}
EXPORT_SYMBOL(pcm2pwm_close);

/*
 * pcm2pwm_enable: Start/Stop outputting PWM signal from PCM2PWM
 * @state		: Parameter to control ON/OFF PWM signal
 * @src			: Address of PCM data
 * @data_sz		: Size of PCM data
 * @cnt			: Counter set for PCM2PWM IP
 * return:
 *        0 if success, otherwise return negative value
 */
extern int pcm2pwm_enable(enum pcm2pwm_request_state state,
				const void *src, unsigned int data_sz, u16 cnt)
{
	int ret = 0;
	u16 val16;
	u32 val32;
	u16 *base;
	base = pcm2pwm_platdevice.base_address;

	if (pcm2pwm_suspend_state == SUSPEND) { /* in suspend state */
		printk(KERN_ERR "[ERR]%s[%d] in suspend state\n",
							__func__, __LINE__);
		return -EBUSY;
	}

	if ((src == NULL) || (data_sz < 0) || (cnt > 2048)) {
		printk(KERN_ERR "[ERR]%s[%d] invalid argument\n",
							__func__, __LINE__);
		return -EINVAL;
	}

	if (PCM2PWM_CLOSE == pcm2pwm_platdevice.state) {
		/* device has not open yet*/
		printk(KERN_ERR "[ERR]%s[%d] device is not open\n",
							__func__, __LINE__);
		return -EINVAL;
	}

	if (STOP_PCM2PWM == state) {
		if (PCM2PWM_STOP == pcm2pwm_platdevice.state) {
			return 0; /* stopping */
		}

		/* stop DMA in case PCM2PWM_START */
		dma_request_release();
		/* clear bit 0 of PWM_CTL */
		__raw_writew(0x0000, IO_ADDRESS(PCM2PWM_CTL(base)));

		/* Release PWMO function out PORT 228 */
		gpio_free(pcm2pwm_platdevice.port_func);

		pcm2pwm_platdevice.state = PCM2PWM_STOP;
		return 0;
	}

	/* update cnt */
	if ((PCM2PWM_START == pcm2pwm_platdevice.state)) {
		/* Update PWM_COUNT */
		__raw_writew(cnt, IO_ADDRESS(PCM2PWM_CNT(base)));
		return 0;
	}

	/* In state PCM2PWM_STOP */

	/* DMA enable and DMA request size setting
	 * Note: Issue a DMA transfer request when FIFO has empty area of
	 * 16 word or more
	 */
	__raw_writew(0x0011, IO_ADDRESS(PCM2PWM_DMA(base)));

	/* PWM_COUNT setting */
	__raw_writew(cnt, IO_ADDRESS(PCM2PWM_CNT(base)));

	/* PWM_CTL setting */
	__raw_writew(0x0001, IO_ADDRESS(PCM2PWM_CTL(base)));

	/*
	 * Setting for CLKGEN-----------------------------------------------
	 * Implemention of iomem_addr_clkgen to access right IO_ADDRESS of
	 * CLKGEN using ioread32/iowrite32
	*/
	/* [CLKGEN] 1.CLKGSYSCTL */
	iowrite32(0x00000000, iomem_addr_clkgen + CLKGSYSCTL);

	/* [CLKGEN] 2.CLKGTIMSEL1: choose port CPUFIFO 0 TIM */
	iowrite32(0x40000000, iomem_addr_clkgen + CLKGTIMSEL1);

	/* [CLKGEN] 3.CLKGCPF0COM:
		Mono, 32fs, 8khz , non-continuous mode, master bit */
	iowrite32(0x00000101, iomem_addr_clkgen + CLKGCPF0COM);
	val32 = ioread32(iomem_addr_clkgen + 0x04);
	val32 = val32 | 0x00000004;

	/* [CLKGEN] 4.CLKGPULSECTL: pulse enable for cpu-fifo0 */
	iowrite32(val32, iomem_addr_clkgen + CLKGPULSECTL);

	/* start DMA transfer */
	ret = dma_request_start(src, data_sz);
	if (ret) {
		printk(KERN_ERR "[ERR]%s[%d]start DMA transfer failed\n",
						__func__, __LINE__);
		/* clear bit 0 of PWM_CTL */
		val16 = __raw_readw(IO_ADDRESS(PCM2PWM_CTL(base)));
		val16 = val16 & 0xFFFE;
		val16 = 0x0000;
		__raw_writew(val16, IO_ADDRESS(PCM2PWM_CTL(base)));
		return ret;
	}

	ret = gpio_request(pcm2pwm_platdevice.port_func,
				pcm2pwm_platdevice.func_name);
	if (ret) {
		printk(KERN_ERR "[ERR]%s[%d] request gpio is failed\n",
							__func__, __LINE__);
		return ret;
	}

	/* update driver state*/
	pcm2pwm_platdevice.state = PCM2PWM_START;

	return ret;
}
EXPORT_SYMBOL(pcm2pwm_enable);


static bool pcm2pwm_dma_filter(struct dma_chan *chan, void *slave)
{
	struct sh_dmae_slave *param = slave;
	chan->private = param;
	return true;
}

/*
 * dma_request_start: start DMA transfer
 * @buf		: Address of transfer buffer
 * @buf_size	: Size of transfer buffer
 * return:
 *        0 if success, otherwise return negative value
 */
static int dma_request_start(const void *buf, unsigned int buf_size)
{
	dma_cap_mask_t mask;
	struct dma_chan *chan = pcm2pwm_dma_dev.tx_chan;
	struct dma_async_tx_descriptor *tx_desc;
	dma_cookie_t tx_cookie;
	int nent;
	dma_filter_fn dma_user_filter_fn;
	struct sh_dmae_slave *dma_user_fn_param;

	pcm2pwm_dma_dev.src = buf;
	pcm2pwm_dma_dev.buf_size = buf_size;

	dma_user_fn_param = kzalloc(sizeof(struct sh_dmae_slave), GFP_KERNEL);
	dma_user_fn_param->slave_id = SHDMA_SLAVE_PCM2PWM_TX;

	dma_user_filter_fn = pcm2pwm_dma_filter;

	if (DMA_STOP != pcm2pwm_dma_dev.dma_state) {
		printk(KERN_ERR "dma_request_start() - EBUSY\n");
		return -EBUSY;
	}

	if ((NULL == buf) || (0 == buf_size)) {
		printk(KERN_ERR "dma_request_start() - EINVAL\n");
		return -EINVAL;
	}

	/* Initialize bit-mask & set bit-mask */
	dma_cap_zero(mask);
	dma_cap_set(DMA_SLAVE, mask);

	/* Request a exclusive channel */
	chan = dma_request_channel(mask, dma_user_filter_fn, dma_user_fn_param);
	if (chan) {
		pcm2pwm_dma_dev.tx_sg = kmalloc(sizeof(struct scatterlist),
								GFP_KERNEL);
		if (!pcm2pwm_dma_dev.tx_sg) {
			printk(KERN_ERR "dma_request_start() - ENOMEM\n");
			return -ENOMEM;
		}
		sg_init_table(pcm2pwm_dma_dev.tx_sg, 1);
		sg_set_page(pcm2pwm_dma_dev.tx_sg, virt_to_page(buf),
					PAGE_SIZE, offset_in_page(buf));
		nent = dma_map_sg(&pcm2pwm_platdevice.pdev->dev,
				pcm2pwm_dma_dev.tx_sg, 1, DMA_TO_DEVICE);
		if (!nent) {
			dma_request_release();
			printk(KERN_ERR "[ERR]%s[%d] dma_map_sg fail\n",
						__func__, __LINE__);
			return -1;
		}
		pcm2pwm_dma_dev.tx_sg_len = nent;
		pcm2pwm_dma_dev.tx_chan = chan;
	} else {
		printk(KERN_ERR "[ERR]%s[%d] dma_request_channel failed\n",
						__func__, __LINE__);
		return -1;
	}

	/* Prepare DMA transfer information */
	if (chan->private == NULL) {
		printk(KERN_ERR "chan->private is NULL\n");
	}
	sg_dma_address(pcm2pwm_dma_dev.tx_sg) =
		(sg_dma_address(pcm2pwm_dma_dev.tx_sg) & ~(PAGE_SIZE  - 1));

		tx_desc = dmaengine_prep_slave_sg(chan,
					pcm2pwm_dma_dev.tx_sg,
					pcm2pwm_dma_dev.tx_sg_len,
					DMA_MEM_TO_DEV,
					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
	if (!tx_desc) {
		dma_request_release();
		printk(KERN_ERR "[ERR]%s[%d]prepare DMA transfer failed\n",
				__func__, __LINE__);
		return -1;
	}
	pcm2pwm_dma_dev.tx_desc = tx_desc;
	/* Set DMA Call back */
	tx_desc->callback = dma_complete_cb;
	tx_desc->callback_param = NULL;
	/* Submit descriptor for transfering */
	tx_cookie = tx_desc->tx_submit(tx_desc);
	if (tx_cookie < 0) {
		printk(KERN_ERR "dma_request_start() - tx_submit() error\n");
		dma_request_release();
		return -1;
	}

	/* Start DMA transfering */
	dma_async_issue_pending(chan);

	/* Set DMA_TRANSMIT to DMA state */
	pcm2pwm_dma_dev.dma_state = DMA_TRANSMIT;

	return 0;
}

/*
 * dma_request_release: release DMA channel
 * return: None
 */
static void dma_request_release(void)
{
	if (DMA_STOP == pcm2pwm_dma_dev.dma_state) {
		printk(KERN_ERR "DMA also in stop state\n");
		return;
	}
	mutex_lock(&pcm2pwm_mutex);
	if (pcm2pwm_dma_dev.tx_chan) {
		dmaengine_device_control(pcm2pwm_dma_dev.tx_chan,
						DMA_TERMINATE_ALL, 0);
		dma_release_channel(pcm2pwm_dma_dev.tx_chan);
		pcm2pwm_dma_dev.tx_sg_len = 0;
		pcm2pwm_dma_dev.tx_chan = NULL;
	}

	pcm2pwm_dma_dev.dma_state = DMA_STOP;
	mutex_unlock(&pcm2pwm_mutex);
}


/*
 * dma_complete_cb: handle callback of DMA when transfer is finished
			(Re-send the buffer set by dma_request_start)
 * return: none
 */
static void dma_complete_cb(void *param)
{
	schedule_work(&dma_work);
}

/*
 * work_dma_callback:
 * return: None
 */
static void work_dma_callback(struct work_struct *work)
{
	struct dma_chan *chan;
	dma_cookie_t tx_cookie;
	chan = pcm2pwm_dma_dev.tx_chan;
	mutex_lock(&pcm2pwm_mutex);
	pcm2pwm_dma_dev.tx_desc = dmaengine_prep_slave_sg(
					chan,
					pcm2pwm_dma_dev.tx_sg,
					pcm2pwm_dma_dev.tx_sg_len,
					DMA_MEM_TO_DEV,
					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
	if (!pcm2pwm_dma_dev.tx_desc) {
		dma_request_release();
		printk(KERN_ERR "[ERR]%s[%d]prepare DMA transfer failed\n",
				__func__, __LINE__);
		return ;
	}

	pcm2pwm_dma_dev.tx_desc->callback = dma_complete_cb;
	pcm2pwm_dma_dev.tx_desc->callback_param = NULL;

	tx_cookie = pcm2pwm_dma_dev.tx_desc->tx_submit(pcm2pwm_dma_dev.tx_desc);
	if (tx_cookie < 0) {
		printk(KERN_ERR "dma_request_start() - tx_submit() error\n");
		dma_request_release();
		return ;
	}
	/* Start DMA transfering */
	dma_async_issue_pending(pcm2pwm_dma_dev.tx_chan);

	mutex_unlock(&pcm2pwm_mutex);

}

/*
 * pcm2pwm_pf_init: init pcm2pwm driver
 * return:
 *        0 if success, otherwise return negative value
 */
static int __init pcm2pwm_pf_init(void)
{
	int ret;
	ret = platform_driver_register(&pcm2pwm_platform_driver);
	if (ret) {
		return ret;
	}
	/* wake-lock init */
	wake_lock_init(&pcm2pwm_wakelock, WAKE_LOCK_SUSPEND,
						"pcm2pwm-wakelock");

	/* mutex init */
	mutex_init(&pcm2pwm_mutex);

	/* init dma work */
	INIT_WORK(&dma_work, work_dma_callback);

#ifdef DEBUG_PCM2PWM
		pcm2pwm_create_debug_if();
#endif /* DEBUG_PCM2PWM */

	pcm2pwm_suspend_state = UN_SUSPEND;

	return 0;
}

/* source code for test */
#ifdef DEBUG_PCM2PWM
#define SAMPLE_NUM	600
#define VIB_CNT_75	4
#define VIB_CNT_ON	1
#define VIB_CNT_OFF	1600
#define VIB_CNT_LINEAR	1024
/* DC Motor*/
static const char test_pcm[SAMPLE_NUM] = {0x02, 0x00, 0x67, 0x00, 0xCE, 0x00,
0x36, 0x01, 0xA0, 0x01, 0x00, 0x02, 0x70, 0x02, 0xD3, 0x02, 0x3C, 0x03, 0x9E,
0x03, 0x05, 0x04, 0x6C, 0x04, 0xD0, 0x04, 0x31, 0x05, 0x90, 0x05, 0xF2, 0x05,
0x51, 0x06, 0xAF, 0x06, 0x0A, 0x07, 0x64, 0x07, 0xBB, 0x07, 0x12, 0x08, 0x65,
0x08, 0xB8, 0x08, 0x08, 0x09, 0x54, 0x09, 0x9E, 0x09, 0xE5, 0x09, 0x2C, 0x0A,
0x6E, 0x0A, 0xAE, 0x0A, 0xEB, 0x0A, 0x25, 0x0B, 0x5A, 0x0B, 0x8C, 0x0B, 0xBC,
0x0B, 0xE7, 0x0B, 0x0F, 0x0C, 0x33, 0x0C, 0x54, 0x0C, 0x71, 0x0C, 0x8A, 0x0C,
0x9F, 0x0C, 0xB0, 0x0C, 0xBD, 0x0C, 0xC5, 0x0C, 0xC9, 0x0C, 0xCA, 0x0C, 0xC6,
0x0C, 0xBC, 0x0C, 0xAF, 0x0C, 0x9E, 0x0C, 0x88, 0x0C, 0x6F, 0x0C, 0x50, 0x0C,
0x2E, 0x0C, 0x08, 0x0C, 0xDC, 0x0B, 0xAC, 0x0B, 0x78, 0x0B, 0x42, 0x0B, 0x05,
0x0B, 0xC5, 0x0A, 0x81, 0x0A, 0x3A, 0x0A, 0xED, 0x09, 0x9C, 0x09, 0x48, 0x09,
0xF0, 0x08, 0x96, 0x08, 0x36, 0x08, 0xD6, 0x07, 0x71, 0x07, 0x09, 0x07, 0x9C,
0x06, 0x2E, 0x06, 0xBF, 0x05, 0x4B, 0x05, 0xD6, 0x04, 0x5E, 0x04, 0xE4, 0x03,
0x68, 0x03, 0xEB, 0x02, 0x6C, 0x02, 0xED, 0x01, 0x6D, 0x01, 0xEA, 0x00, 0x67,
0x00, 0x1C, 0x00, 0xA0, 0x00, 0x22, 0x01, 0xA7, 0x01, 0x2A, 0x02, 0xAC, 0x02,
0x2D, 0x03, 0xAE, 0x03, 0x2E, 0x04, 0xAB, 0x04, 0x27, 0x05, 0xA2, 0x05, 0x1B,
0x06, 0x8F, 0x06, 0x04, 0x07, 0x74, 0x07, 0xE1, 0x07, 0x4B, 0x08, 0xB1, 0x08,
0x14, 0x09, 0x71, 0x09, 0xCD, 0x09, 0x23, 0x0A, 0x76, 0x0A, 0xC3, 0x0A, 0x0D,
0x0B, 0x51, 0x0B, 0x91, 0x0B, 0xC9, 0x0B, 0xFE, 0x0B, 0x2C, 0x0C, 0x54, 0x0C,
0x76, 0x0C, 0x92, 0x0C, 0xA9, 0x0C, 0xBA, 0x0C, 0xC6, 0x0C, 0xC8, 0x0C, 0xC8,
0x0C, 0xC0, 0x0C, 0xB3, 0x0C, 0x9E, 0x0C, 0x83, 0x0C, 0x63, 0x0C, 0x3A, 0x0C,
0x0D, 0x0C, 0xD7, 0x0B, 0x9D, 0x0B, 0x5C, 0x0B, 0x17, 0x0B, 0xCA, 0x0A, 0x79,
0x0A, 0x22, 0x0A, 0xC4, 0x09, 0x61, 0x09, 0xFA, 0x08, 0x8D, 0x08, 0x1A, 0x08,
0xA4, 0x07, 0x2A, 0x07, 0xAB, 0x06, 0x28, 0x06, 0xA1, 0x05, 0x17, 0x05, 0x8B,
0x04, 0xFB, 0x03, 0x69, 0x03, 0xD4, 0x02, 0x3E, 0x02, 0xA5, 0x01, 0x0C, 0x01,
0x71, 0x00, 0xD7, 0xFF, 0xC4, 0x00, 0x60, 0x01, 0xFB, 0x01, 0x96, 0x02, 0x2E,
0x03, 0xC5, 0x03, 0x5A, 0x04, 0xED, 0x04, 0x7D, 0x05, 0x0A, 0x06, 0x95, 0x06,
0x1B, 0x07, 0x9D, 0x07, 0x1B, 0x08, 0x95, 0x08, 0x09, 0x09, 0x78, 0x09, 0xE1,
0x09, 0x44, 0x0A, 0xA1, 0x0A, 0xF8, 0x0A, 0x47, 0x0B, 0x91, 0x0B, 0xD4, 0x0B,
0x0E, 0x0C, 0x41, 0x0C, 0x6D, 0x0C, 0x91, 0x0C, 0xAD, 0x0C, 0xBF, 0x0C, 0xCB,
0x0C, 0xCD, 0x0C, 0xC9, 0x0C, 0xBA, 0x0C, 0xA4, 0x0C, 0x86, 0x0C, 0x5F, 0x0C,
0x30, 0x0C, 0xF7, 0x0B, 0xB6, 0x0B, 0x70, 0x0B, 0x21, 0x0B, 0xCA, 0x0A, 0x6A,
0x0A, 0x04, 0x0A, 0x98, 0x09, 0x23, 0x09, 0xA8, 0x08, 0x28, 0x08, 0xA2, 0x07,
0x15, 0x07, 0x84, 0x06, 0xEC, 0x05, 0x52, 0x05, 0xB3, 0x04, 0x10, 0x04, 0x6B,
0x03, 0xC1, 0x02, 0x17, 0x02, 0x6A, 0x01, 0xBD, 0x00, 0xF3, 0xFF, 0xA0, 0x00,
0x51, 0x01, 0xFF, 0x01, 0xAC, 0x02, 0x59, 0x03, 0x02, 0x04, 0xAA, 0x04, 0x4D,
0x05, 0xED, 0x05, 0x89, 0x06, 0x21, 0x07, 0xB3, 0x07, 0x3F, 0x08, 0xC4, 0x08,
0x45, 0x09, 0xBD, 0x09, 0x2D, 0x0A, 0x98, 0x0A, 0xF9, 0x0A, 0x54, 0x0B, 0xA3,
0x0B, 0xEB, 0x0B, 0x29, 0x0C, 0x5D, 0x0C, 0x88, 0x0C, 0xA9, 0x0C, 0xC0, 0x0C,
0xCC, 0x0C, 0xCF, 0x0C, 0xC7, 0x0C, 0xB5, 0x0C, 0x97, 0x0C, 0x71, 0x0C, 0x3E,
0x0C, 0x03, 0x0C, 0xBE, 0x0B, 0x6E, 0x0B, 0x15, 0x0B, 0xB2, 0x0A, 0x47, 0x0A,
0xD3, 0x09, 0x56, 0x09, 0xD1, 0x08, 0x44, 0x08, 0xB1, 0x07, 0x15, 0x07, 0x73,
0x06, 0xCB, 0x05, 0x1E, 0x05, 0x6D, 0x04, 0xB8, 0x03, 0xFF, 0x02, 0x43, 0x02,
0x84, 0x01, 0xC5, 0x00,
};

static const char test_pcm_300x_300x[SAMPLE_NUM] = {0x12, 0x00, 0x9F, 0x03,
0x3E, 0x07, 0xE6, 0x0A, 0xA0, 0x0E, 0x00, 0x12, 0xF0, 0x15, 0x6B, 0x19, 0x1C,
0x1D, 0x8E, 0x20, 0x2D, 0x24, 0xCC, 0x27, 0x50, 0x2B, 0xB9, 0x2E, 0x10, 0x32,
0x82, 0x35, 0xD9, 0x38, 0x27, 0x3C, 0x5A, 0x3F, 0x84, 0x42, 0x93, 0x45, 0xA2,
0x48, 0x8D, 0x4B, 0x78, 0x4E, 0x48, 0x51, 0xF4, 0x53, 0x8E, 0x56, 0x0D, 0x59,
0x8C, 0x5B, 0xDE, 0x5D, 0x1E, 0x60, 0x43, 0x62, 0x4D, 0x64, 0x2A, 0x66, 0xEC,
0x67, 0x9C, 0x69, 0x1F, 0x6B, 0x87, 0x6C, 0xCB, 0x6D, 0xF4, 0x6E, 0xF9, 0x6F,
0xDA, 0x70, 0x97, 0x71, 0x30, 0x72, 0xA5, 0x72, 0xED, 0x72, 0x11, 0x73, 0x1A,
0x73, 0xF6, 0x72, 0x9C, 0x72, 0x27, 0x72, 0x8E, 0x71, 0xC8, 0x70, 0xE7, 0x6F,
0xD0, 0x6E, 0x9E, 0x6D, 0x48, 0x6C, 0xBC, 0x6A, 0x0C, 0x69, 0x38, 0x67, 0x52,
0x65, 0x2D, 0x63, 0xED, 0x60, 0x89, 0x5E, 0x0A, 0x5C, 0x55, 0x59, 0x7C, 0x56,
0x88, 0x53, 0x70, 0x50, 0x46, 0x4D, 0xE6, 0x49, 0x86, 0x46, 0xF9, 0x42, 0x51,
0x3F, 0x7C, 0x3B, 0x9E, 0x37, 0xB7, 0x33, 0xA3, 0x2F, 0x86, 0x2B, 0x4E, 0x27,
0x04, 0x23, 0xA8, 0x1E, 0x43, 0x1A, 0xCC, 0x15, 0x55, 0x11, 0xD5, 0x0C, 0x3A,
0x08, 0x9F, 0x03, 0xFC, 0x00, 0xA0, 0x05, 0x32, 0x0A, 0xDF, 0x0E, 0x7A, 0x13,
0x0C, 0x18, 0x95, 0x1C, 0x1E, 0x21, 0x9E, 0x25, 0x03, 0x2A, 0x5F, 0x2E, 0xB2,
0x32, 0xF3, 0x36, 0x07, 0x3B, 0x24, 0x3F, 0x14, 0x43, 0xE9, 0x46, 0xA3, 0x4A,
0x39, 0x4E, 0xB4, 0x51, 0xF9, 0x54, 0x35, 0x58, 0x3B, 0x5B, 0x26, 0x5E, 0xDB,
0x60, 0x75, 0x63, 0xD9, 0x65, 0x19, 0x68, 0x11, 0x6A, 0xEE, 0x6B, 0x8C, 0x6D,
0xF4, 0x6E, 0x26, 0x70, 0x22, 0x71, 0xF1, 0x71, 0x8A, 0x72, 0xF6, 0x72, 0x08,
0x73, 0x08, 0x73, 0xC0, 0x72, 0x4B, 0x72, 0x8E, 0x71, 0x9B, 0x70, 0x7B, 0x6F,
0x0A, 0x6E, 0x75, 0x6C, 0x8F, 0x6A, 0x85, 0x68, 0x3C, 0x66, 0xCF, 0x63, 0x1A,
0x61, 0x41, 0x5E, 0x32, 0x5B, 0xE4, 0x57, 0x69, 0x54, 0xCA, 0x50, 0xF5, 0x4C,
0xEA, 0x48, 0xC4, 0x44, 0x7A, 0x40, 0x03, 0x3C, 0x68, 0x37, 0xA9, 0x32, 0xCF,
0x2D, 0xE3, 0x28, 0xD3, 0x23, 0xB1, 0x1E, 0x74, 0x19, 0x2E, 0x14, 0xCD, 0x0E,
0x6C, 0x09, 0xF9, 0x03, 0x8F, 0xFE, 0xE4, 0x06, 0x60, 0x0C, 0xD3, 0x11, 0x46,
0x17, 0x9E, 0x1C, 0xED, 0x21, 0x2A, 0x27, 0x55, 0x2C, 0x65, 0x31, 0x5A, 0x36,
0x3D, 0x3B, 0xF3, 0x3F, 0x85, 0x44, 0xF3, 0x48, 0x3D, 0x4D, 0x51, 0x51, 0x38,
0x55, 0xE9, 0x58, 0x64, 0x5C, 0xA9, 0x5F, 0xB8, 0x62, 0x7F, 0x65, 0x19, 0x68,
0x74, 0x6A, 0x7E, 0x6C, 0x49, 0x6E, 0xD5, 0x6F, 0x19, 0x71, 0x15, 0x72, 0xB7,
0x72, 0x23, 0x73, 0x35, 0x73, 0x11, 0x73, 0x8A, 0x72, 0xC4, 0x71, 0xB6, 0x70,
0x57, 0x6F, 0xB0, 0x6D, 0xAF, 0x6B, 0x66, 0x69, 0xF0, 0x66, 0x29, 0x64, 0x1A,
0x61, 0xBA, 0x5D, 0x24, 0x5A, 0x58, 0x56, 0x3B, 0x52, 0xE8, 0x4D, 0x68, 0x49,
0xB2, 0x44, 0xBD, 0x3F, 0xA4, 0x3A, 0x4C, 0x35, 0xE2, 0x2F, 0x4B, 0x2A, 0x90,
0x24, 0xC3, 0x1E, 0xC9, 0x18, 0xCF, 0x12, 0xBA, 0x0C, 0xA5, 0x06, 0x8B, 0xFF,
0xA0, 0x05, 0xD9, 0x0B, 0xF7, 0x11, 0x0C, 0x18, 0x21, 0x1E, 0x12, 0x24, 0xFA,
0x29, 0xB5, 0x2F, 0x55, 0x35, 0xD1, 0x3A, 0x29, 0x40, 0x4B, 0x45, 0x37, 0x4A,
0xE4, 0x4E, 0x6D, 0x53, 0xA5, 0x57, 0x95, 0x5B, 0x58, 0x5F, 0xC1, 0x62, 0xF4,
0x65, 0xBB, 0x68, 0x43, 0x6B, 0x71, 0x6D, 0x45, 0x6F, 0xC8, 0x70, 0xF1, 0x71,
0xC0, 0x72, 0x2C, 0x73, 0x47, 0x73, 0xFF, 0x72, 0x5D, 0x72, 0x4F, 0x71, 0xF9,
0x6F, 0x2E, 0x6E, 0x1B, 0x6C, 0xAE, 0x69, 0xDE, 0x66, 0xBD, 0x63, 0x42, 0x60,
0x7F, 0x5C, 0x6B, 0x58, 0x06, 0x54, 0x59, 0x4F, 0x64, 0x4A, 0x39, 0x45, 0xBD,
0x3F, 0x0B, 0x3A, 0x23, 0x34, 0x0E, 0x2E, 0xD5, 0x27, 0x78, 0x21, 0xF7, 0x1A,
0x5B, 0x14, 0xA4, 0x0D, 0xED, 0x06,
};

/* sine wave PCM data (Linear Motor) */
static const char test_pcm_300x_300x_fadein[SAMPLE_NUM] = {0x00, 0x00, 0x03,
0x00, 0x0D, 0x00, 0x1E, 0x00, 0x36, 0x00, 0x53, 0x00, 0x79, 0x00, 0xA4, 0x00,
0xD6, 0x00, 0x0E, 0x01, 0x4D, 0x01, 0x93, 0x01, 0xDF, 0x01, 0x2F, 0x02, 0x85,
0x02, 0xE3, 0x02, 0x46, 0x03, 0xAE, 0x03, 0x1A, 0x04, 0x8C, 0x04, 0x01, 0x05,
0x7D, 0x05, 0xFB, 0x05, 0x7E, 0x06, 0x04, 0x07, 0x8D, 0x07, 0x18, 0x08, 0xA6,
0x08, 0x38, 0x09, 0xCB, 0x09, 0x5F, 0x0A, 0xF5, 0x0A, 0x8C, 0x0B, 0x21, 0x0C,
0xB6, 0x0C, 0x4C, 0x0D, 0xDF, 0x0D, 0x72, 0x0E, 0x02, 0x0F, 0x91, 0x0F, 0x1C,
0x10, 0xA5, 0x10, 0x29, 0x11, 0xA9, 0x11, 0x25, 0x12, 0x9A, 0x12, 0x0A, 0x13,
0x76, 0x13, 0xD9, 0x13, 0x33, 0x14, 0x88, 0x14, 0xD5, 0x14, 0x19, 0x15, 0x55,
0x15, 0x86, 0x15, 0xB0, 0x15, 0xD0, 0x15, 0xE2, 0x15, 0xEB, 0x15, 0xE8, 0x15,
0xDE, 0x15, 0xC3, 0x15, 0x9E, 0x15, 0x6C, 0x15, 0x30, 0x15, 0xE3, 0x14, 0x88,
0x14, 0x22, 0x14, 0xAD, 0x13, 0x2E, 0x13, 0x9C, 0x12, 0x03, 0x12, 0x58, 0x11,
0xA0, 0x10, 0xD5, 0x0F, 0x01, 0x0F, 0x23, 0x0E, 0x32, 0x0D, 0x36, 0x0C, 0x2B,
0x0B, 0x14, 0x0A, 0xEF, 0x08, 0xBF, 0x07, 0x82, 0x06, 0x3D, 0x05, 0xEC, 0x03,
0x8B, 0x02, 0x22, 0x01, 0x50, 0x00, 0xCD, 0x01, 0x4D, 0x03, 0xDE, 0x04, 0x72,
0x06, 0x0B, 0x08, 0xAA, 0x09, 0x51, 0x0B, 0xFD, 0x0C, 0xA9, 0x0E, 0x59, 0x10,
0x0E, 0x12, 0xC4, 0x13, 0x72, 0x15, 0x2B, 0x17, 0xDA, 0x18, 0x87, 0x1A, 0x31,
0x1C, 0xD3, 0x1D, 0x72, 0x1F, 0x03, 0x21, 0x96, 0x22, 0x19, 0x24, 0x97, 0x25,
0x05, 0x27, 0x6D, 0x28, 0xC4, 0x29, 0x10, 0x2B, 0x42, 0x2C, 0x6C, 0x2D, 0x80,
0x2E, 0x7F, 0x2F, 0x69, 0x30, 0x3E, 0x31, 0x01, 0x32, 0xAD, 0x32, 0x47, 0x33,
0xB9, 0x33, 0x23, 0x34, 0x6C, 0x34, 0xA0, 0x34, 0xB1, 0x34, 0xA8, 0x34, 0x88,
0x34, 0x40, 0x34, 0xE3, 0x33, 0x5D, 0x33, 0xC2, 0x32, 0x04, 0x32, 0x30, 0x31,
0x34, 0x30, 0x21, 0x2F, 0xED, 0x2D, 0x94, 0x2C, 0x1E, 0x2B, 0x8F, 0x29, 0xDD,
0x27, 0x08, 0x26, 0x1D, 0x24, 0x18, 0x22, 0xF3, 0x1F, 0xB2, 0x1D, 0x56, 0x1B,
0xE2, 0x18, 0x5B, 0x16, 0xB7, 0x13, 0x00, 0x11, 0x31, 0x0E, 0x53, 0x0B, 0x5C,
0x08, 0x5B, 0x05, 0x46, 0x02, 0x2C, 0xFF, 0xFE, 0x03, 0x36, 0x07, 0x73, 0x0A,
0xBB, 0x0D, 0xFC, 0x10, 0x42, 0x14, 0x87, 0x17, 0xCA, 0x1A, 0x07, 0x1E, 0x3D,
0x21, 0x70, 0x24, 0x91, 0x27, 0xA4, 0x2A, 0xA9, 0x2D, 0x9F, 0x30, 0x7B, 0x33,
0x42, 0x36, 0xEE, 0x38, 0x7D, 0x3B, 0xF0, 0x3D, 0x46, 0x40, 0x72, 0x42, 0x86,
0x44, 0x75, 0x46, 0x33, 0x48, 0xCA, 0x49, 0x3A, 0x4B, 0x7C, 0x4C, 0x8F, 0x4D,
0x67, 0x4E, 0x1B, 0x4F, 0x91, 0x4F, 0xE2, 0x4F, 0xEE, 0x4F, 0xCD, 0x4F, 0x77,
0x4F, 0xE6, 0x4E, 0x1F, 0x4E, 0x15, 0x4D, 0xD4, 0x4B, 0x6D, 0x4A, 0xC7, 0x48,
0xE8, 0x46, 0xC7, 0x44, 0x78, 0x42, 0xFB, 0x3F, 0x3B, 0x3D, 0x4A, 0x3A, 0x30,
0x37, 0xE4, 0x33, 0x60, 0x30, 0xB8, 0x2C, 0xD6, 0x28, 0xDC, 0x24, 0xB5, 0x20,
0x69, 0x1C, 0x03, 0x18, 0x70, 0x13, 0xD1, 0x0E, 0x12, 0x0A, 0x48, 0x05, 0xA3,
0xFF, 0x83, 0x04, 0x8C, 0x09, 0x8A, 0x0E, 0x8D, 0x13, 0x9A, 0x18, 0x95, 0x1D,
0x94, 0x22, 0x78, 0x27, 0x51, 0x2C, 0x16, 0x31, 0xC6, 0x35, 0x53, 0x3A, 0xBC,
0x3E, 0xF9, 0x42, 0x1F, 0x47, 0x09, 0x4B, 0xBC, 0x4E, 0x50, 0x52, 0x9C, 0x55,
0xC0, 0x58, 0x8C, 0x5B, 0x25, 0x5E, 0x73, 0x60, 0x76, 0x62, 0x34, 0x64, 0xA5,
0x65, 0xC8, 0x66, 0x92, 0x67, 0x15, 0x68, 0x3E, 0x68, 0x14, 0x68, 0x87, 0x67,
0xB5, 0x66, 0x76, 0x65, 0xF0, 0x63, 0x14, 0x62, 0xD6, 0x5F, 0x48, 0x5D, 0x5F,
0x5A, 0x2C, 0x57, 0xA6, 0x53, 0xCB, 0x4F, 0xA3, 0x4B, 0x2E, 0x47, 0x7C, 0x42,
0x72, 0x3D, 0x2A, 0x38, 0xA3, 0x32, 0xE5, 0x2C, 0xF9, 0x26, 0xDE, 0x20, 0x94,
0x1A, 0x23, 0x14, 0x8B, 0x0D, 0xE7, 0x06,
};

static char test_pcm_300x[] = {
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
};

static const struct file_operations pcm2pwm_test_fops = {
	.owner = THIS_MODULE,
	.write = pcm2pwm_test_write,
};

static struct miscdevice pcm2pwm_test_miscdev = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "pcm2pwm_test",
	.fops = &pcm2pwm_test_fops,
};

static void pcm2pwm_create_debug_if(void)
{
	misc_register(&pcm2pwm_test_miscdev);
}

static void pcm2pwm_delete_debug_if(void)
{
	misc_deregister(&pcm2pwm_test_miscdev);
}

static ssize_t pcm2pwm_test_write(struct file *filp, const char __user *buf,
						size_t count, loff_t *ppos)
{
	int number_request = 0;
	int ret;
	sscanf(buf, "%d", &number_request);

	switch (number_request) {
	case 1:
		ret = pcm2pwm_open();
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	/* DC Motor */
	case 2:
		ret = pcm2pwm_enable(START_PCM2PWM, test_pcm_300x,
							550, 4);
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	case 3:
		ret = pcm2pwm_enable(START_PCM2PWM, test_pcm_300x_300x,
							550, 16);
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	case 4:
		ret = pcm2pwm_enable(STOP_PCM2PWM, test_pcm_300x_300x,
							0, 0);
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	case 5:
		ret = pcm2pwm_enable(START_PCM2PWM, test_pcm_300x,
							550, 32);
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	case 6:
		ret = pcm2pwm_enable(START_PCM2PWM, test_pcm_300x_300x,
							550, 64);
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	case 7:
		ret = pcm2pwm_close();
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	case 8:
		ret = pcm2pwm_enable(START_PCM2PWM, test_pcm_300x_300x_fadein,
							550, 128);
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	case 9:
		ret = pcm2pwm_enable(START_PCM2PWM, test_pcm_300x_300x_fadein,
							550, 1024);
		if (ret) {
			printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] ret = %d\n",
						__func__, __LINE__, ret);
		}
		break;
	default:
		printk(KERN_ERR "[DBG PCM2PWM ERR]%s[%d] Request not correct\n",
					__func__, __LINE__);
	}

	return count;
}
#endif /* DEBUG_PCM2PWM */

module_init(pcm2pwm_pf_init);
module_exit(pcm2pwm_pf_exit);

MODULE_AUTHOR("Renesas Mobile");
MODULE_DESCRIPTION("Driver that controls PCM2PWM IP");
MODULE_LICENSE("GPL v2");
